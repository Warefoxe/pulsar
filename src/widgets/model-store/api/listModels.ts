import { Credentials, PipelineType } from '@huggingface/hub';
import type { ModelLibraryKey, TransformersInfo } from '@huggingface/tasks';

export type JsonPrimitive = string | number | boolean | null;

export type JsonValue = JsonPrimitive | JsonObject | JsonArray;

export type JsonArray = JsonValue[] | readonly JsonValue[];

type JsonObject = { [Key in string]: JsonValue } & {
  [Key in string]?: JsonValue | undefined;
};

const HUB_URL = 'https://huggingface.co';

class HubApiError extends Error {
  statusCode: number;

  url: string;

  requestId?: string;

  data?: JsonObject;

  constructor(url: string, statusCode: number, requestId?: string, message?: string) {
    super(message);

    this.statusCode = statusCode;
    this.requestId = requestId;
    this.url = url;
  }
}

interface ApiModelIndex {
  name: string;
  results: {
    task: {
      /**
       * Example: automatic-speech-recognition
       Use task id from https://github.com/huggingface/huggingface.js/blob/main/packages/tasks/src/tasksData.ts
       */
      type: string;
      /**
       * Example: Speech Recognition
       */
      name?: string;
    };
    /**
     * This will switch to required at some point.
     in any case, we need them to link to PWC
     */
    dataset?: {
      /**
       * Example: common_voice. Use dataset id from https://hf.co/datasets
       */
      type: string;
      /**
       * A pretty name for the dataset. Example: Common Voice zh-CN
       Also encode config params into the name if relevant.
       */
      name: string;
      /**
       * Optional. The name of the dataset configuration used in `load_dataset()`
       */
      config?: string;
      /**
       * Optional. Example: test
       */
      split?: string;
      /**
       * Optional. Example: 5503434ddd753f426f4b38109466949a1217c2bb
       */
      revision?: string;
      args?:
        | string
        | {
            /**
             * String Property
             */
            [x: string]: string;
          };
    };
    metrics: {
      /**
       * Example: wer. Use metric id from https://hf.co/metrics
       */
      type: string;
      /**
       * Required. Example: 20.0 or "20.0 ± 1.2"
       */
      value: unknown;
      /**
       * Example: Test WER
       */
      name?: string;
      /**
       * Optional. The name of the metric configuration used in `load_metric()`.
       */
      config?: string;
      args?:
        | string
        | {
            /**
             * String Property
             */
            [x: string]: string;
          };
      /**
       * [Automatically computed, do not set] Dynamically overriden by huggingface in API calls to indicate if it was verified by Hugging Face.
       */
      verified?: boolean;
      /**
       * Generated by Hugging Face to prove the results are valid. <add doc link>
       */
      verifyToken?: string;
    }[];
    /**
     * The source for this evaluation result.
     */
    source?: {
      /**
       * Example: Open LLM Leaderboard
       */
      name?: string;
      /**
       * Example: https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard
       */
      url: string;
    };
  }[];
}

interface ApiWidgetExampleFromModelcard {
  example_title?: string;
  group?: string;
  text?: string;
  src?: string;
  table?: {
    /**
     * (string | number)[] Property
     */
    [x: string]: (string | number)[];
  };
  structured_data?: {
    /**
     * (string | number)[] Property
     */
    [x: string]: (string | number)[];
  };
  candidate_labels?: string;
  messages?: {
    role: 'system' | 'user' | 'assistant';
    content: string;
  }[];
  multi_class?: boolean;
  source_sentence?: string;
  sentences?: string[];
  parameters?: {
    aggregation_strategy?: string;
    top_k?: number;
    top_p?: number;
    temperature?: number;
    max_new_tokens?: number;
    do_sample?: boolean;
    negative_prompt?: string;
    guidance_scale?: number;
    num_inference_steps?: number;
  };
  output?:
    | {
        label: string;
        score: number;
      }[]
    | {
        answer: string;
        score: number;
      }
    | {
        text: string;
      }
    | {
        url: string;
      };
}

export function parseLinkHeader(header: string): Record<string, string> {
  const regex = /<(https?:[/][/][^>]+)>;\s+rel="([^"]+)"/g;

  return Object.fromEntries([...header.matchAll(regex)].map(([, url, rel]) => [rel, url]));
}

export function pick<T, K extends keyof T>(o: T, props: K[] | ReadonlyArray<K>): Pick<T, K> {
  return Object.assign(
    {},
    ...props.map((prop) => {
      if (o[prop] !== undefined) {
        return { [prop]: o[prop] };
      }
    })
  );
}

interface ApiModelIndex {
  name: string;
  results: {
    task: {
      /**
       * Example: automatic-speech-recognition
       Use task id from https://github.com/huggingface/huggingface.js/blob/main/packages/tasks/src/tasksData.ts
       */
      type: string;
      /**
       * Example: Speech Recognition
       */
      name?: string;
    };
    /**
     * This will switch to required at some point.
     in any case, we need them to link to PWC
     */
    dataset?: {
      /**
       * Example: common_voice. Use dataset id from https://hf.co/datasets
       */
      type: string;
      /**
       * A pretty name for the dataset. Example: Common Voice zh-CN
       Also encode config params into the name if relevant.
       */
      name: string;
      /**
       * Optional. The name of the dataset configuration used in `load_dataset()`
       */
      config?: string;
      /**
       * Optional. Example: test
       */
      split?: string;
      /**
       * Optional. Example: 5503434ddd753f426f4b38109466949a1217c2bb
       */
      revision?: string;
      args?:
        | string
        | {
            /**
             * String Property
             */
            [x: string]: string;
          };
    };
    metrics: {
      /**
       * Example: wer. Use metric id from https://hf.co/metrics
       */
      type: string;
      /**
       * Required. Example: 20.0 or "20.0 ± 1.2"
       */
      value: unknown;
      /**
       * Example: Test WER
       */
      name?: string;
      /**
       * Optional. The name of the metric configuration used in `load_metric()`.
       */
      config?: string;
      args?:
        | string
        | {
            /**
             * String Property
             */
            [x: string]: string;
          };
      /**
       * [Automatically computed, do not set] Dynamically overriden by huggingface in API calls to indicate if it was verified by Hugging Face.
       */
      verified?: boolean;
      /**
       * Generated by Hugging Face to prove the results are valid. <add doc link>
       */
      verifyToken?: string;
    }[];
    /**
     * The source for this evaluation result.
     */
    source?: {
      /**
       * Example: Open LLM Leaderboard
       */
      name?: string;
      /**
       * Example: https://huggingface.co/spaces/HuggingFaceH4/open_llm_leaderboard
       */
      url: string;
    };
  }[];
}

interface ApiModelInfo {
  _id: string;
  id: string;
  arxivIds: string[];
  author?: string;
  cardData?: ApiModelMetadata;
  cardError: unknown;
  cardExists?: true;
  config: unknown;
  contributors: Array<{ user: string; _id: string }>;
  disabled: boolean;
  discussionsDisabled: boolean;
  doi?: { id: string; commit: string };
  downloads: number;
  downloadsAllTime: number;
  files: string[];
  gitalyUid: string;
  lastAuthor: { email: string; user?: string };
  lastModified: string; // convert to date
  library_name?: ModelLibraryKey;
  likes: number;
  likesRecent: number;
  private: boolean;
  gated: false | 'auto' | 'manual';
  sha: string;
  spaces: string[];
  updatedAt: string; // convert to date
  createdAt: string; // convert to date
  pipeline_tag: PipelineType;
  tags: string[];
  'model-index': unknown;
  safetensors?: {
    parameters: Record<string, number>;
    total: number;
  };
  transformersInfo?: TransformersInfo;
}

interface ApiModelMetadata {
  datasets?: string | string[];
  license?: any;
  license_name?: string;
  license_link?: 'LICENSE' | 'LICENSE.md' | string;
  license_details?: string;
  inference?:
    | boolean
    | {
        parameters?: {
          aggregation_strategy?: string;
          top_k?: number;
          top_p?: number;
          temperature?: number;
          max_new_tokens?: number;
          do_sample?: boolean;
          negative_prompt?: string;
          guidance_scale?: number;
          num_inference_steps?: number;
        };
      };
  language?: string | string[];
  language_bcp47?: string[];
  language_details?: string;
  tags?: string[];
  pipeline_tag?: string;
  co2_eq_emissions?:
    | number
    | {
        /**
         * Emissions in grams of CO2
         */
        emissions: number;
        /**
         * source of the information, either directly from AutoTrain, code carbon or from a scientific article documenting the model
         */
        source?: string;
        /**
         * pre-training or fine-tuning
         */
        training_type?: string;
        /**
         * as granular as possible, for instance Quebec, Canada or Brooklyn, NY, USA
         */
        geographical_location?: string;
        /**
         * how much compute and what kind, e.g. 8 v100 GPUs
         */
        hardware_used?: string;
      };
  library_name?: string;
  thumbnail?: string | null;
  description?: string | null;
  mask_token?: string;
  widget?: ApiWidgetExampleFromModelcard[];
  'model-index'?: ApiModelIndex[];
  finetuned_from?: string;
  base_model?: string | string[];
  instance_prompt?: string | null;
  extra_gated_prompt?: string;
  extra_gated_fields?: {
    /**
     * "text" | "checkbox" | "date_picker" | "country" | "ip_location" | { type: "text" | "checkbox" | "date_picker" | "country" | "ip_location" } | { type: "select", options: Array<string | { label: string; value: string; }> } Property
     */
    [x: string]:
      | 'text'
      | 'checkbox'
      | 'date_picker'
      | 'country'
      | 'ip_location'
      | { type: 'text' | 'checkbox' | 'date_picker' | 'country' | 'ip_location' }
      | { type: 'select'; options: Array<string | { label: string; value: string }> };
  };
  extra_gated_heading?: string;
  extra_gated_description?: string;
  extra_gated_button_content?: string;
}

const EXPAND_KEYS = [
  'pipeline_tag',
  'private',
  'gated',
  'downloads',
  'likes',
  'lastModified',
] as const satisfies readonly (keyof ApiModelInfo)[];

const EXPANDABLE_KEYS = [
  'author',
  'cardData',
  'config',
  'createdAt',
  'disabled',
  'downloads',
  'downloadsAllTime',
  'gated',
  'gitalyUid',
  'lastModified',
  'library_name',
  'likes',
  'model-index',
  'pipeline_tag',
  'private',
  'safetensors',
  'sha',
  // "siblings",
  'spaces',
  'tags',
  'transformersInfo',
] as const satisfies readonly (keyof ApiModelInfo)[];

function checkCredentials(credentials?: Credentials): void {
  if (!credentials || credentials.accessToken === undefined || credentials.accessToken === null) {
    return;
  }

  if (!credentials.accessToken.startsWith('hf_')) {
    throw new TypeError("Your access token must start with 'hf_'");
  }
}

async function createApiError(
  response: Response,
  opts?: { requestId?: string; message?: string }
): Promise<never> {
  const error = new HubApiError(
    response.url,
    response.status,
    response.headers.get('X-Request-Id') ?? opts?.requestId
  );

  error.message = `Api error with status ${error.statusCode}${
    opts?.message ? `. ${opts.message}` : ''
  }`;

  const trailer = [
    `URL: ${error.url}`,
    error.requestId ? `Request ID: ${error.requestId}` : undefined,
  ]
    .filter(Boolean)
    .join('. ');

  if (response.headers.get('Content-Type')?.startsWith('application/json')) {
    const json = await response.json();
    error.message = json.error || json.message || error.message;
    error.data = json;
  } else {
    error.data = { message: await response.text() };
  }

  error.message += `. ${trailer}`;

  throw error;
}

export interface ModelEntry {
  id: string;
  name: string;
  private: boolean;
  gated: false | 'auto' | 'manual';
  task?: PipelineType;
  likes: number;
  downloads: number;
  updatedAt: Date;
}

export async function* listModels<
  const T extends Exclude<(typeof EXPANDABLE_KEYS)[number], (typeof EXPAND_KEYS)[number]> = never
>(params?: {
  search?: {
    /**
     * Will search in the model name for matches
     */
    query?: string;
    owner?: string;
    task?: any;
    tags?: string[];
  };
  credentials?: any;
  hubUrl?: string;
  additionalFields?: T[];
  /**
   * Set to limit the number of models returned.
   */
  limit?: number;
  /**
   * Custom fetch function to use instead of the default one, for example to use a proxy or edit headers.
   */
  fetch?: typeof fetch;
  sort?: (typeof EXPANDABLE_KEYS)[number];
  direction?: 1 | -1;
}): AsyncGenerator<ModelEntry & Pick<ApiModelInfo, T>> {
  checkCredentials(params?.credentials);
  let totalToFetch = params?.limit ?? Infinity;
  const search = new URLSearchParams([
    ...Object.entries({
      limit: String(Math.min(totalToFetch, 500)),
      ...(params?.search?.owner ? { author: params.search.owner } : undefined),
      ...(params?.search?.task ? { pipeline_tag: params.search.task } : undefined),
      ...(params?.search?.query ? { search: params.search.query } : undefined),
      ...(params?.sort ? { sort: params.sort } : undefined),
      ...(params?.direction ? { direction: String(params.direction) } : undefined),
    }),
    ...(params?.search?.tags?.map((tag) => ['filter', tag]) ?? []),
    ...EXPAND_KEYS.map((val) => ['expand', val] satisfies [string, string]),
    ...(params?.additionalFields?.map((val) => ['expand', val] satisfies [string, string]) ?? []),
  ]).toString();

  let url: string | undefined = `${params?.hubUrl || HUB_URL}/api/models?${search}`;

  while (url) {
    const res: Response = await (params?.fetch ?? fetch)(url, {
      headers: {
        accept: 'application/json',
        ...(params?.credentials
          ? { Authorization: `Bearer ${params.credentials.accessToken}` }
          : undefined),
      },
    });

    if (!res.ok) {
      throw await createApiError(res);
    }

    const items: ApiModelInfo[] = await res.json();

    for (const item of items) {
      yield {
        ...(params?.additionalFields && pick(item, params.additionalFields)),
        id: item._id,
        name: item.id,
        private: item.private,
        task: item.pipeline_tag,
        downloads: item.downloads,
        gated: item.gated,
        likes: item.likes,
        updatedAt: new Date(item.lastModified),
      } as ModelEntry & Pick<ApiModelInfo, T>;
      totalToFetch--;

      if (totalToFetch <= 0) {
        return;
      }
    }

    const linkHeader = res.headers.get('Link');

    url = linkHeader ? parseLinkHeader(linkHeader).next : undefined;
    // Could update url to reduce the limit if we don't need the whole 500 of the next batch.
  }
}
